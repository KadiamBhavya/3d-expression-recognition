import numpy as np
import pandas as pd
from sklearn.metrics import accuracy_score, confusion_matrix, precision_score, recall_score
from sklearn.model_selection import KFold
from data_processor import DataProcessor
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

class ClassifierTrainer:
   
    def get_processed_data(self,data_type, df):
        # Static method to preprocess data based on specified type
        if data_type == 'o':
            return df.iloc[:, :249], df.iloc[:, 249:250]# Return original data
        elif data_type in ['x', 'y', 'z']:
            df_rotated = self.rotate_data(data_type, df)# Rotate data based on specified axis
            return df_rotated.iloc[:, :249], df_rotated.iloc[:, 249:250] # Return rotated data
        elif data_type == 't':
            df_translated = self.translate_data(df) # Translate data to origin
            return df_translated.iloc[:, :249], df_translated.iloc[:, 249:250] # Return translated data
        else:
            return None, None # Return None for invalid data type

    
    def rotate_data(self,axis, df):
        # Static method to rotate data based on specified axis
        original_landmarks = np.array(df.iloc[:, :249]).reshape(-1, 83 , 3) # Reshape data to 3D array
        rotated_landmarks = DataProcessor.rotate_points_3d(original_landmarks, axis=axis) # Rotate landmarks
        df_rotated = pd.DataFrame(rotated_landmarks.reshape(-1, 249)) # Reshape data to DataFrame
        df_rotated['label'] = df['label'] # Add label column
        return df_rotated # Return rotated DataFrame


   
    def translate_data(self,df):
        # Static method to translate data to origin
        original_landmarks = np.array(df.iloc[:, :249]).reshape(-1, 83 , 3) # Reshape data to 3D array
        translated_landmarks = DataProcessor.translate_to_origin(original_landmarks)
        df_translated = pd.DataFrame(translated_landmarks.reshape(-1, 249), columns=[f'feature_{i}' for i in range(249)]) # Reshape data to DataFrame
        df_translated['label'] = df['label'] # Add label column
        return df_translated # Return translated DataFrame
        
   
    def train_classifier(self,classifier, features, labels):
        # Static method to train classifier and evaluate performance
        model = classifier() # Instantiate classifier
        kf = KFold(n_splits=10) # Initialize KFold for 10-fold cross-validation
        evaluation_metrics = {'conf_matrices': [], 'accuracies': [], 'precisions': [], 'recalls': []} # Initialize dictionary to store evaluation metrics

        for train_indices, test_indices in kf.split(features):
            # Iterate through train/test indices generated by KFold
            train_labels, test_labels ,train_features  , test_features = labels[train_indices], labels[test_indices],features.iloc[train_indices], features.iloc[test_indices]  # Split labels into train/test sets
            
            model.fit(train_features, train_labels) # Train the classifier
            predictions = model.predict(test_features) # Make predictions
            evaluation_metrics['conf_matrices'].append(confusion_matrix(test_labels, predictions)) # Compute confusion matrix
            evaluation_metrics['accuracies'].append(accuracy_score(test_labels, predictions)) # Compute accuracy
            evaluation_metrics['precisions'].append(precision_score(test_labels, predictions, average='weighted', zero_division=0)) # Compute precision
            evaluation_metrics['recalls'].append(recall_score(test_labels, predictions, average='weighted', zero_division=0)) # Compute recall

        self.print_results(evaluation_metrics)
        
    
    def print_results(self,metrics):
        # Static method to print average evaluation metrics
        avg_cm = np.mean(metrics['conf_matrices'], axis=0).astype(int) # Compute average confusion matrix
        avg_acc = np.mean(metrics['accuracies']) # Compute average accuracy
        avg_prec = np.mean(metrics['precisions']) # Compute average precision
        avg_rec = np.mean(metrics['recalls'])     # Compute average recall

        print("Average Metrics:")
        print("Mean Accuracy:", avg_acc)
        print("Mean Precision:", avg_prec)
        print("Mean Recall:", avg_rec)
        print("Average Confusion Matrix:")
        print(avg_cm)

    
   
    def visualization(self,df):
        sample = np.random.choice(len(df))
        t_df=self.translate_data(df)
        x_df=self.rotate_data('x', df)
        y_df=self.rotate_data('y', df)
        z_df=self.rotate_data('z', df)
            # Extract landmarks for the selected sample
        sample_landmarks = {
            "Original": np.array(df.iloc[sample, :249]).reshape(83, 3),
            "Translated": np.array(t_df.iloc[sample, :249]).reshape(83, 3),
            "X Rotated": np.array(x_df.iloc[sample, :249]).reshape(83, 3),
            "Y Rotated": np.array(y_df.iloc[sample, :249]).reshape(83, 3),
            "Z Rotated": np.array(z_df.iloc[sample, :249]).reshape(83, 3)
        }

            # Plot 3D subplots for each type of landmarks
        fig, axes = plt.subplots(1, 5, figsize=(28,5), subplot_kw={'projection': '3d'})

            # Iterate over each type of landmarks and plot
        for plot, (label, landmarks) in zip(axes, sample_landmarks.items()):
            plot.scatter(landmarks[:, 0], landmarks[:, 1], landmarks[:, 2], c='blue', marker='o')
            plot.set_title(f'{label}')
            plot.set_xlabel('X-axis')
            plot.set_ylabel('Y-axis')
            plot.set_zlabel('Z-axis')
        plt.show()